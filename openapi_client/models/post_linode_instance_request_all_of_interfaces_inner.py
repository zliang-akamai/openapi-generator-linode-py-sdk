# coding: utf-8

"""
    Linode API

    [Read the API documentation](https://techdocs.akamai.com/linode-api/reference/api).

    The version of the OpenAPI document: 4.189.2
    Contact: support@linode.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.post_linode_instance_request_all_of_interfaces_inner_ipv4 import PostLinodeInstanceRequestAllOfInterfacesInnerIpv4
from typing import Optional, Set
from typing_extensions import Self

class PostLinodeInstanceRequestAllOfInterfacesInner(BaseModel):
    """
    The Network Interface to apply to this Linode's configuration profile.
    """ # noqa: E501
    active: Optional[StrictBool] = Field(default=None, description="Returns `true` if the Interface is in use, meaning that Compute Instance has been booted using the Configuration Profile to which the Interface belongs. Otherwise returns `false`.")
    id: Optional[StrictInt] = Field(default=None, description="The unique ID representing this Interface.")
    ip_ranges: Optional[List[StrictStr]] = Field(default=None, description="An array of IPv4 CIDR VPC Subnet ranges that are routed to this Interface.  - Array items are only allowed for `vpc` type Interfaces. - This must be empty for non-`vpc` type Interfaces.  For requests:  - Addresses in submitted ranges must not already be actively assigned. - Submitting values replaces any existing values. - Submitting an empty array removes any existing values. - Omitting this property results in no change to existing values.")
    ipam_address: Optional[StrictStr] = Field(default=None, description="This Network Interface's private IP address in Classless Inter-Domain Routing (CIDR) notation.  For `vlan` purpose Interfaces:  - Must be unique among the Linode's Interfaces to avoid conflicting addresses. - Should be unique among devices attached to the VLAN to avoid conflict. - The Linode is configured to use this address for the associated Interface upon reboot if Network Helper is enabled. If Network Helper is disabled, the address can be enabled with [manual static IP configuration](https://www.linode.com/docs/guides/manual-network-configuration/).  For `public` purpose Interfaces:  - In requests, must be an empty string (`\"\"`) or `null` if included. - In responses, always returns `null`.  For `vpc` purpose Interfaces:  - In requests, must be an empty string (`\"\"`) or `null` if included. - In responses, always returns `null`.")
    ipv4: Optional[PostLinodeInstanceRequestAllOfInterfacesInnerIpv4] = None
    label: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]] = Field(default=None, description="The name of this Interface.  For `vlan` purpose Interfaces:  - Required. - Must be unique among the Linode's Interfaces (a Linode cannot be attached to the same VLAN multiple times). - Can only contain ASCII letters, numbers, and hyphens (`-`). You can't use two consecutive hyphens (`--`). - If the VLAN label is new, a VLAN is created. Up to 10 VLANs can be created in each data center region. To view your active VLANs, run the [List VLANs](https://techdocs.akamai.com/linode-api/reference/get-vlans) operation.  For `public` purpose Interfaces:  - In requests, must be an empty string (`\"\"`) or `null` if included. - In responses, always returns `null`.  For `vpc` purpose Interfaces:  - In requests, must be an empty string (`\"\"`) or `null` if included. - In responses, always returns `null`.")
    primary: Optional[StrictBool] = Field(default=None, description="The primary Interface is configured as the default route to the Linode.  Each Configuration Profile can have up to one `\"primary\": true` Interface at a time.  Must be `false` for `vlan` type Interfaces.  If no Interface is configured as the primary, the first non-`vlan` type Interface in the `interfaces` array is automatically treated as the primary Interface.")
    purpose: StrictStr = Field(description="The type of Interface.  - `public`   - Only one `public` Interface per Linode can be defined.   - The Linode's default public IPv4 address is assigned to the `public` Interface.   - A Linode must have a public Interface in the first/eth0 position to be reachable via the public internet upon boot without additional system configuration. If no `public` Interface is configured, the Linode is not directly reachable via the public internet. In this case, access can only be established via [LISH](https://www.linode.com/docs/products/compute/compute-instances/guides/lish/) or other Linodes connected to the same VLAN or VPC.  - `vlan`   - Configuring a `vlan` purpose Interface attaches this Linode to the VLAN with the specified `label`.   - The Linode is configured to use the specified `ipam_address`, if any.  - `vpc`   - Configuring a `vpc` purpose Interface attaches this Linode to the existing VPC Subnet with the specified `subnet_id`.   - When the Interface is activated, the Linode is configured to use an IP address from the range in the assigned VPC Subnet. See `ipv4.vpc` for more information.")
    subnet_id: Optional[StrictInt] = Field(default=None, description="The `id` of the VPC Subnet for this Interface.  In requests, this value is used to assign a Linode to a VPC Subnet.  - Required for `vpc` type Interfaces. - Returns `null` for non-`vpc` type Interfaces. - Once a VPC Subnet is assigned to an Interface, it cannot be updated. - The Linode must be rebooted with the Interface's Configuration Profile to complete assignment to a VPC Subnet.")
    vpc_id: Optional[StrictInt] = Field(default=None, description="The `id` of the VPC configured for this Interface. Returns `null` for non-`vpc` type Interfaces.")
    __properties: ClassVar[List[str]] = ["active", "id", "ip_ranges", "ipam_address", "ipv4", "label", "primary", "purpose", "subnet_id", "vpc_id"]

    @field_validator('label')
    def label_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"[a-zA-Z0-9-]+", value):
            raise ValueError(r"must validate the regular expression /[a-zA-Z0-9-]+/")
        return value

    @field_validator('purpose')
    def purpose_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['public', 'vlan', 'vpc']):
            raise ValueError("must be one of enum values ('public', 'vlan', 'vpc')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PostLinodeInstanceRequestAllOfInterfacesInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "active",
            "id",
            "vpc_id",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of ipv4
        if self.ipv4:
            _dict['ipv4'] = self.ipv4.to_dict()
        # set to None if ip_ranges (nullable) is None
        # and model_fields_set contains the field
        if self.ip_ranges is None and "ip_ranges" in self.model_fields_set:
            _dict['ip_ranges'] = None

        # set to None if ipam_address (nullable) is None
        # and model_fields_set contains the field
        if self.ipam_address is None and "ipam_address" in self.model_fields_set:
            _dict['ipam_address'] = None

        # set to None if label (nullable) is None
        # and model_fields_set contains the field
        if self.label is None and "label" in self.model_fields_set:
            _dict['label'] = None

        # set to None if subnet_id (nullable) is None
        # and model_fields_set contains the field
        if self.subnet_id is None and "subnet_id" in self.model_fields_set:
            _dict['subnet_id'] = None

        # set to None if vpc_id (nullable) is None
        # and model_fields_set contains the field
        if self.vpc_id is None and "vpc_id" in self.model_fields_set:
            _dict['vpc_id'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PostLinodeInstanceRequestAllOfInterfacesInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "active": obj.get("active"),
            "id": obj.get("id"),
            "ip_ranges": obj.get("ip_ranges"),
            "ipam_address": obj.get("ipam_address"),
            "ipv4": PostLinodeInstanceRequestAllOfInterfacesInnerIpv4.from_dict(obj["ipv4"]) if obj.get("ipv4") is not None else None,
            "label": obj.get("label"),
            "primary": obj.get("primary"),
            "purpose": obj.get("purpose"),
            "subnet_id": obj.get("subnet_id"),
            "vpc_id": obj.get("vpc_id")
        })
        return _obj


