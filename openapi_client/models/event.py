# coding: utf-8

"""
    Linode API

    [Read the API documentation](https://techdocs.akamai.com/linode-api/reference/api).

    The version of the OpenAPI document: 4.189.2
    Contact: support@linode.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.get_events200_response_data_inner_entity import GetEvents200ResponseDataInnerEntity
from openapi_client.models.get_events200_response_data_inner_secondary_entity import GetEvents200ResponseDataInnerSecondaryEntity
from typing import Optional, Set
from typing_extensions import Self

class Event(BaseModel):
    """
    A collection of Event objects. An Event is an action taken against an entity related to your Account. For example, booting a Linode would create an Event. The Events returned depends on your grants.
    """ # noqa: E501
    action: Optional[StrictStr] = Field(default=None, description="The action that caused this Event. New actions may be added in the future.")
    created: Optional[datetime] = Field(default=None, description="When this Event was created.")
    duration: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The total duration in seconds that it takes for the Event to complete.")
    entity: Optional[GetEvents200ResponseDataInnerEntity] = None
    id: Optional[StrictInt] = Field(default=None, description="The unique ID of this Event.")
    message: Optional[StrictStr] = Field(default=None, description="Provides additional information about the event. Additional information may include, but is not limited to, a more detailed representation of events which can help diagnose non-obvious failures.")
    percent_complete: Optional[StrictInt] = Field(default=None, description="A percentage estimating the amount of time remaining for an Event. Returns `null` for notification events.")
    rate: Optional[StrictStr] = Field(default=None, description="The rate of completion of the Event. Only some Events will return rate; for example, migration and resize Events.")
    read: Optional[StrictBool] = Field(default=None, description="If this Event has been read.")
    secondary_entity: Optional[GetEvents200ResponseDataInnerSecondaryEntity] = None
    seen: Optional[StrictBool] = Field(default=None, description="If this Event has been seen.")
    status: Optional[StrictStr] = Field(default=None, description="The current status of this Event.")
    time_remaining: Optional[StrictStr] = Field(default=None, description="The estimated time remaining until the completion of this Event. This value is only returned for some in-progress migration events. For all other in-progress events, the `percent_complete` attribute will indicate about how much more work is to be done.")
    username: Optional[StrictStr] = Field(default=None, description="The username of the User who caused the Event.")
    __properties: ClassVar[List[str]] = ["action", "created", "duration", "entity", "id", "message", "percent_complete", "rate", "read", "secondary_entity", "seen", "status", "time_remaining", "username"]

    @field_validator('action')
    def action_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['account_update', 'account_settings_update', 'backups_enable', 'backups_cancel', 'backups_restore', 'community_question_reply', 'community_like', 'credit_card_updated', 'disk_create', 'disk_delete', 'disk_update', 'disk_duplicate', 'disk_imagize', 'disk_resize', 'dns_record_create', 'dns_record_delete', 'dns_record_update', 'dns_zone_create', 'dns_zone_delete', 'dns_zone_import', 'dns_zone_update', 'entity_transfer_accept', 'entity_transfer_cancel', 'entity_transfer_create', 'entity_transfer_fail', 'entity_transfer_stale', 'firewall_apply', 'firewall_create', 'firewall_delete', 'firewall_disable', 'firewall_enable', 'firewall_update', 'firewall_device_add', 'firewall_device_remove', 'host_reboot', 'image_delete', 'image_update', 'image_upload', 'ipaddress_update', 'lassie_reboot', 'lish_boot', 'linode_addip', 'linode_boot', 'linode_clone', 'linode_create', 'linode_delete', 'linode_update', 'linode_deleteip', 'linode_migrate', 'linode_migrate_datacenter', 'linode_migrate_datacenter_create', 'linode_mutate', 'linode_mutate_create', 'linode_reboot', 'linode_rebuild', 'linode_resize', 'linode_resize_create', 'linode_shutdown', 'linode_snapshot', 'linode_config_create', 'linode_config_delete', 'linode_config_update', 'lke_cluster_create', 'lke_cluster_update', 'lke_cluster_delete', 'lke_cluster_recycle', 'lke_cluster_regenerate', 'lke_node_create', 'lke_node_delete', 'lke_node_recycle', 'lke_pool_create', 'lke_pool_delete', 'lke_pool_recycle', 'lke_kubeconfig_regenerate', 'lke_token_rotate', 'longviewclient_create', 'longviewclient_delete', 'longviewclient_update', 'managed_disabled', 'managed_enabled', 'managed_service_create', 'managed_service_delete', 'nodebalancer_create', 'nodebalancer_delete', 'nodebalancer_update', 'nodebalancer_config_create', 'nodebalancer_config_delete', 'nodebalancer_config_update', 'nodebalancer_node_create', 'nodebalancer_node_delete', 'nodebalancer_node_update', 'oauth_client_create', 'oauth_client_delete', 'oauth_client_secret_reset', 'oauth_client_update', 'obj_access_key_create', 'obj_access_key_delete', 'obj_access_key_update', 'password_reset', 'payment_method_add', 'payment_submitted', 'placement_group_assign', 'placement_group_became_compliant', 'placement_group_became_non_compliant', 'placement_group_create', 'placement_group_delete', 'placement_group_unassign', 'placement_group_update', 'profile_update', 'stackscript_create', 'stackscript_delete', 'stackscript_update', 'stackscript_publicize', 'stackscript_revise', 'subnet_create', 'subnet_delete', 'subnet_update', 'tag_create', 'tag_delete', 'tfa_disabled', 'tfa_enabled', 'ticket_attachment_upload', 'ticket_create', 'ticket_update', 'token_create', 'token_delete', 'token_update', 'user_create', 'user_update', 'user_delete', 'user_ssh_key_add', 'user_ssh_key_delete', 'user_ssh_key_update', 'vlan_attach', 'vlan_detach', 'volume_attach', 'volume_clone', 'volume_create', 'volume_delete', 'volume_update', 'volume_detach', 'volume_resize', 'vpc_create', 'vpc_delete', 'vpc_update']):
            raise ValueError("must be one of enum values ('account_update', 'account_settings_update', 'backups_enable', 'backups_cancel', 'backups_restore', 'community_question_reply', 'community_like', 'credit_card_updated', 'disk_create', 'disk_delete', 'disk_update', 'disk_duplicate', 'disk_imagize', 'disk_resize', 'dns_record_create', 'dns_record_delete', 'dns_record_update', 'dns_zone_create', 'dns_zone_delete', 'dns_zone_import', 'dns_zone_update', 'entity_transfer_accept', 'entity_transfer_cancel', 'entity_transfer_create', 'entity_transfer_fail', 'entity_transfer_stale', 'firewall_apply', 'firewall_create', 'firewall_delete', 'firewall_disable', 'firewall_enable', 'firewall_update', 'firewall_device_add', 'firewall_device_remove', 'host_reboot', 'image_delete', 'image_update', 'image_upload', 'ipaddress_update', 'lassie_reboot', 'lish_boot', 'linode_addip', 'linode_boot', 'linode_clone', 'linode_create', 'linode_delete', 'linode_update', 'linode_deleteip', 'linode_migrate', 'linode_migrate_datacenter', 'linode_migrate_datacenter_create', 'linode_mutate', 'linode_mutate_create', 'linode_reboot', 'linode_rebuild', 'linode_resize', 'linode_resize_create', 'linode_shutdown', 'linode_snapshot', 'linode_config_create', 'linode_config_delete', 'linode_config_update', 'lke_cluster_create', 'lke_cluster_update', 'lke_cluster_delete', 'lke_cluster_recycle', 'lke_cluster_regenerate', 'lke_node_create', 'lke_node_delete', 'lke_node_recycle', 'lke_pool_create', 'lke_pool_delete', 'lke_pool_recycle', 'lke_kubeconfig_regenerate', 'lke_token_rotate', 'longviewclient_create', 'longviewclient_delete', 'longviewclient_update', 'managed_disabled', 'managed_enabled', 'managed_service_create', 'managed_service_delete', 'nodebalancer_create', 'nodebalancer_delete', 'nodebalancer_update', 'nodebalancer_config_create', 'nodebalancer_config_delete', 'nodebalancer_config_update', 'nodebalancer_node_create', 'nodebalancer_node_delete', 'nodebalancer_node_update', 'oauth_client_create', 'oauth_client_delete', 'oauth_client_secret_reset', 'oauth_client_update', 'obj_access_key_create', 'obj_access_key_delete', 'obj_access_key_update', 'password_reset', 'payment_method_add', 'payment_submitted', 'placement_group_assign', 'placement_group_became_compliant', 'placement_group_became_non_compliant', 'placement_group_create', 'placement_group_delete', 'placement_group_unassign', 'placement_group_update', 'profile_update', 'stackscript_create', 'stackscript_delete', 'stackscript_update', 'stackscript_publicize', 'stackscript_revise', 'subnet_create', 'subnet_delete', 'subnet_update', 'tag_create', 'tag_delete', 'tfa_disabled', 'tfa_enabled', 'ticket_attachment_upload', 'ticket_create', 'ticket_update', 'token_create', 'token_delete', 'token_update', 'user_create', 'user_update', 'user_delete', 'user_ssh_key_add', 'user_ssh_key_delete', 'user_ssh_key_update', 'vlan_attach', 'vlan_detach', 'volume_attach', 'volume_clone', 'volume_create', 'volume_delete', 'volume_update', 'volume_detach', 'volume_resize', 'vpc_create', 'vpc_delete', 'vpc_update')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['failed', 'finished', 'notification', 'scheduled', 'started']):
            raise ValueError("must be one of enum values ('failed', 'finished', 'notification', 'scheduled', 'started')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Event from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "action",
            "created",
            "duration",
            "id",
            "percent_complete",
            "rate",
            "read",
            "seen",
            "status",
            "time_remaining",
            "username",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of entity
        if self.entity:
            _dict['entity'] = self.entity.to_dict()
        # override the default output from pydantic by calling `to_dict()` of secondary_entity
        if self.secondary_entity:
            _dict['secondary_entity'] = self.secondary_entity.to_dict()
        # set to None if message (nullable) is None
        # and model_fields_set contains the field
        if self.message is None and "message" in self.model_fields_set:
            _dict['message'] = None

        # set to None if time_remaining (nullable) is None
        # and model_fields_set contains the field
        if self.time_remaining is None and "time_remaining" in self.model_fields_set:
            _dict['time_remaining'] = None

        # set to None if username (nullable) is None
        # and model_fields_set contains the field
        if self.username is None and "username" in self.model_fields_set:
            _dict['username'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Event from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "action": obj.get("action"),
            "created": obj.get("created"),
            "duration": obj.get("duration"),
            "entity": GetEvents200ResponseDataInnerEntity.from_dict(obj["entity"]) if obj.get("entity") is not None else None,
            "id": obj.get("id"),
            "message": obj.get("message"),
            "percent_complete": obj.get("percent_complete"),
            "rate": obj.get("rate"),
            "read": obj.get("read"),
            "secondary_entity": GetEvents200ResponseDataInnerSecondaryEntity.from_dict(obj["secondary_entity"]) if obj.get("secondary_entity") is not None else None,
            "seen": obj.get("seen"),
            "status": obj.get("status"),
            "time_remaining": obj.get("time_remaining"),
            "username": obj.get("username")
        })
        return _obj


