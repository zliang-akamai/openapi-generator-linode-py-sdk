# coding: utf-8

"""
    Linode API

    [Read the API documentation](https://techdocs.akamai.com/linode-api/reference/api).

    The version of the OpenAPI document: 4.189.2
    Contact: support@linode.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.get_linode_configs200_response_data_inner_devices import GetLinodeConfigs200ResponseDataInnerDevices
from openapi_client.models.get_linode_configs200_response_data_inner_helpers import GetLinodeConfigs200ResponseDataInnerHelpers
from openapi_client.models.post_linode_instance_request_all_of_interfaces_inner import PostLinodeInstanceRequestAllOfInterfacesInner
from typing import Optional, Set
from typing_extensions import Self

class PostAddLinodeConfigRequest(BaseModel):
    """
    PostAddLinodeConfigRequest
    """ # noqa: E501
    comments: Optional[StrictStr] = Field(default=None, description="Optional field for arbitrary User comments on this Config.")
    devices: GetLinodeConfigs200ResponseDataInnerDevices
    helpers: Optional[GetLinodeConfigs200ResponseDataInnerHelpers] = None
    id: Optional[StrictInt] = Field(default=None, description="The ID of this Config.")
    interfaces: Optional[Annotated[List[PostLinodeInstanceRequestAllOfInterfacesInner], Field(min_length=1, max_length=3)]] = Field(default=None, description="An array of Network Interfaces to add to this Linode's Configuration Profile. At least one and up to three Interface objects can exist in this array. The position in the array determines which of the Linode's network Interfaces is configured:  - First [0]:  eth0 - Second [1]: eth1 - Third [2]:  eth2  When updating a Linode's Interfaces, _each Interface must be redefined_. An empty `interfaces` array results in a default `public` type Interface configuration only.  If no public Interface is configured, public IP addresses are still assigned to the Linode but will not be usable without manual configuration.  __Note__. Changes to Linode Interface configurations can be enabled by rebooting the Linode.  `vpc` details  See the [VPC documentation](https://www.linode.com/docs/products/networking/vpc/#technical-specifications) guide for its specifications and limitations.  `vlan` details  - Only Next Generation Network (NGN) data centers support VLANs. Run the [List regions](https://techdocs.akamai.com/linode-api/reference/get-regions) operation to view the capabilities of data center regions. If a VLAN is attached to your Linode and you attempt to migrate or clone it to a non-NGN data center, the migration or cloning will not initiate. If a Linode cannot be migrated or cloned because of an incompatibility, you will be prompted to select a different data center or contact support. - See the [VLANs Overview](https://www.linode.com/docs/products/networking/vlans/#technical-specifications) guide to view additional specifications and limitations.")
    kernel: Optional[StrictStr] = Field(default='linode/latest-64bit', description="A Kernel ID to boot a Linode with. Here are examples of commonly used kernels:  - `linode/latest-64bit` (default): Our latest kernel at the time of instance boot/reboot. - `linode/grub2`: The upstream distribution-supplied kernel that is installed on the primary disk, or a custom kernel if installed. - `linode/direct-disk`: The MBR (Master Boot Record) of the primary disk/root device, used instead of a Linux kernel.  For a complete list of options, run the [List kernels](https://techdocs.akamai.com/linode-api/reference/get-kernels) operation.")
    label: Annotated[str, Field(min_length=1, strict=True, max_length=48)] = Field(description="The Config's label is for display purposes only.")
    memory_limit: Optional[StrictInt] = Field(default=None, description="Defaults to the total RAM of the Linode.")
    root_device: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="The root device to boot.  - If no value or an invalid value is provided, root device will default to `/dev/sda`. - If the device specified at the root device location is not mounted, the Linode will not boot until a device is mounted.")
    run_level: Optional[StrictStr] = Field(default=None, description="Defines the state of your Linode after booting. Defaults to `default`.")
    virt_mode: Optional[StrictStr] = Field(default=None, description="Controls the virtualization mode. Defaults to `paravirt`.  - `paravirt` is suitable for most cases. Linodes running in paravirt mode share some qualities with the host, ultimately making it run faster since there is less transition between it and the host. - `fullvirt` affords more customization, but is slower because 100% of the VM is virtualized.")
    __properties: ClassVar[List[str]] = ["comments", "devices", "helpers", "id", "interfaces", "kernel", "label", "memory_limit", "root_device", "run_level", "virt_mode"]

    @field_validator('root_device')
    def root_device_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"a-z, A-Z, 0-9, \/, _, -", value):
            raise ValueError(r"must validate the regular expression /a-z, A-Z, 0-9, \/, _, -/")
        return value

    @field_validator('run_level')
    def run_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['default', 'single', 'binbash']):
            raise ValueError("must be one of enum values ('default', 'single', 'binbash')")
        return value

    @field_validator('virt_mode')
    def virt_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['paravirt', 'fullvirt']):
            raise ValueError("must be one of enum values ('paravirt', 'fullvirt')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PostAddLinodeConfigRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "id",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of devices
        if self.devices:
            _dict['devices'] = self.devices.to_dict()
        # override the default output from pydantic by calling `to_dict()` of helpers
        if self.helpers:
            _dict['helpers'] = self.helpers.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in interfaces (list)
        _items = []
        if self.interfaces:
            for _item_interfaces in self.interfaces:
                if _item_interfaces:
                    _items.append(_item_interfaces.to_dict())
            _dict['interfaces'] = _items
        # set to None if comments (nullable) is None
        # and model_fields_set contains the field
        if self.comments is None and "comments" in self.model_fields_set:
            _dict['comments'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PostAddLinodeConfigRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "comments": obj.get("comments"),
            "devices": GetLinodeConfigs200ResponseDataInnerDevices.from_dict(obj["devices"]) if obj.get("devices") is not None else None,
            "helpers": GetLinodeConfigs200ResponseDataInnerHelpers.from_dict(obj["helpers"]) if obj.get("helpers") is not None else None,
            "id": obj.get("id"),
            "interfaces": [PostLinodeInstanceRequestAllOfInterfacesInner.from_dict(_item) for _item in obj["interfaces"]] if obj.get("interfaces") is not None else None,
            "kernel": obj.get("kernel") if obj.get("kernel") is not None else 'linode/latest-64bit',
            "label": obj.get("label"),
            "memory_limit": obj.get("memory_limit"),
            "root_device": obj.get("root_device"),
            "run_level": obj.get("run_level"),
            "virt_mode": obj.get("virt_mode")
        })
        return _obj


